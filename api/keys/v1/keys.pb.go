// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/keys/v1/keys.proto

package keys

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AuthRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *AuthRequest) Reset()         { *m = AuthRequest{} }
func (m *AuthRequest) String() string { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()    {}
func (*AuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{0}
}
func (m *AuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthRequest.Merge(m, src)
}
func (m *AuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthRequest proto.InternalMessageInfo

func (m *AuthRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type AuthResponse struct {
	// JWT that can be used for authz
	AuthJWT string `protobuf:"bytes,1,opt,name=authJWT,proto3" json:"auth_jwt"`
}

func (m *AuthResponse) Reset()         { *m = AuthResponse{} }
func (m *AuthResponse) String() string { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()    {}
func (*AuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{1}
}
func (m *AuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthResponse.Merge(m, src)
}
func (m *AuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthResponse proto.InternalMessageInfo

func (m *AuthResponse) GetAuthJWT() string {
	if m != nil {
		return m.AuthJWT
	}
	return ""
}

type RegisterRequest struct {
	KID        string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Expiry     int64  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry,omitempty"`
	SigAlg     string `protobuf:"bytes,3,opt,name=sigAlg,proto3" json:"sig_alg,omitempty"`
	SigBits    int32  `protobuf:"varint,4,opt,name=sigBits,proto3" json:"sig_bits,omitempty"`
	EncAlg     string `protobuf:"bytes,5,opt,name=encAlg,proto3" json:"enc_alg,omitempty"`
	EncBits    int32  `protobuf:"varint,6,opt,name=encBits,proto3" json:"enc_bits,omitempty"`
	AuthTTL    int64  `protobuf:"varint,7,opt,name=authTTL,proto3" json:"auth_ttl,omitempty"`
	RefreshTTL int64  `protobuf:"varint,8,opt,name=refreshTTL,proto3" json:"refresh_ttl,omitempty"`
	// RefreshStrategy is used in RenewJWT to decide wheather to issue new refresh
	// token with access token or not this option applies to all renewJWT requests
	RefreshStrategy string `protobuf:"bytes,9,opt,name=refreshStrategy,proto3" json:"refresh_strategy,omitempty"`
}

func (m *RegisterRequest) Reset()         { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()    {}
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{2}
}
func (m *RegisterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterRequest.Merge(m, src)
}
func (m *RegisterRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterRequest proto.InternalMessageInfo

func (m *RegisterRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RegisterRequest) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *RegisterRequest) GetSigAlg() string {
	if m != nil {
		return m.SigAlg
	}
	return ""
}

func (m *RegisterRequest) GetSigBits() int32 {
	if m != nil {
		return m.SigBits
	}
	return 0
}

func (m *RegisterRequest) GetEncAlg() string {
	if m != nil {
		return m.EncAlg
	}
	return ""
}

func (m *RegisterRequest) GetEncBits() int32 {
	if m != nil {
		return m.EncBits
	}
	return 0
}

func (m *RegisterRequest) GetAuthTTL() int64 {
	if m != nil {
		return m.AuthTTL
	}
	return 0
}

func (m *RegisterRequest) GetRefreshTTL() int64 {
	if m != nil {
		return m.RefreshTTL
	}
	return 0
}

func (m *RegisterRequest) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type RegisterResponse struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	AuthJWT         string `protobuf:"bytes,2,opt,name=authJWT,proto3" json:"auth_jwt"`
	PubSigKey       []byte `protobuf:"bytes,3,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey       []byte `protobuf:"bytes,4,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Expiry          int64  `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry"`
	Valid           bool   `protobuf:"varint,6,opt,name=valid,proto3" json:"valid"`
	RefreshStrategy string `protobuf:"bytes,7,opt,name=refreshStrategy,proto3" json:"refresh_strategy"`
}

func (m *RegisterResponse) Reset()         { *m = RegisterResponse{} }
func (m *RegisterResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterResponse) ProtoMessage()    {}
func (*RegisterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{3}
}
func (m *RegisterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterResponse.Merge(m, src)
}
func (m *RegisterResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterResponse proto.InternalMessageInfo

func (m *RegisterResponse) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RegisterResponse) GetAuthJWT() string {
	if m != nil {
		return m.AuthJWT
	}
	return ""
}

func (m *RegisterResponse) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *RegisterResponse) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *RegisterResponse) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *RegisterResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *RegisterResponse) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type UpdateKeysRequest struct {
	KID        string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Expiry     int64  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry,omitempty"`
	SigAlg     string `protobuf:"bytes,3,opt,name=sigAlg,proto3" json:"sig_alg,omitempty"`
	SigBits    int32  `protobuf:"varint,4,opt,name=sigBits,proto3" json:"sig_bits,omitempty"`
	EncAlg     string `protobuf:"bytes,5,opt,name=encAlg,proto3" json:"enc_alg,omitempty"`
	EncBits    int32  `protobuf:"varint,6,opt,name=encBits,proto3" json:"enc_bits,omitempty"`
	AuthTTL    int64  `protobuf:"varint,7,opt,name=authTTL,proto3" json:"auth_ttl,omitempty"`
	RefreshTTL int64  `protobuf:"varint,8,opt,name=refreshTTL,proto3" json:"refresh_ttl,omitempty"`
	// RefreshStrategy is used in RenewJWT to decide wheather to issue new refresh
	// token with access token or not this option applies to all renewJWT requests
	RefreshStrategy string `protobuf:"bytes,9,opt,name=refreshStrategy,proto3" json:"refresh_strategy,omitempty"`
}

func (m *UpdateKeysRequest) Reset()         { *m = UpdateKeysRequest{} }
func (m *UpdateKeysRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateKeysRequest) ProtoMessage()    {}
func (*UpdateKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{4}
}
func (m *UpdateKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeysRequest.Merge(m, src)
}
func (m *UpdateKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeysRequest proto.InternalMessageInfo

func (m *UpdateKeysRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *UpdateKeysRequest) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *UpdateKeysRequest) GetSigAlg() string {
	if m != nil {
		return m.SigAlg
	}
	return ""
}

func (m *UpdateKeysRequest) GetSigBits() int32 {
	if m != nil {
		return m.SigBits
	}
	return 0
}

func (m *UpdateKeysRequest) GetEncAlg() string {
	if m != nil {
		return m.EncAlg
	}
	return ""
}

func (m *UpdateKeysRequest) GetEncBits() int32 {
	if m != nil {
		return m.EncBits
	}
	return 0
}

func (m *UpdateKeysRequest) GetAuthTTL() int64 {
	if m != nil {
		return m.AuthTTL
	}
	return 0
}

func (m *UpdateKeysRequest) GetRefreshTTL() int64 {
	if m != nil {
		return m.RefreshTTL
	}
	return 0
}

func (m *UpdateKeysRequest) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type UpdateKeysResponse struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	AuthJWT         string `protobuf:"bytes,2,opt,name=authJWT,proto3" json:"auth_jwt"`
	PubSigKey       []byte `protobuf:"bytes,3,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey       []byte `protobuf:"bytes,4,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Expiry          int64  `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry"`
	Valid           bool   `protobuf:"varint,6,opt,name=valid,proto3" json:"valid"`
	RefreshStrategy string `protobuf:"bytes,7,opt,name=refreshStrategy,proto3" json:"refresh_strategy"`
}

func (m *UpdateKeysResponse) Reset()         { *m = UpdateKeysResponse{} }
func (m *UpdateKeysResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateKeysResponse) ProtoMessage()    {}
func (*UpdateKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{5}
}
func (m *UpdateKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeysResponse.Merge(m, src)
}
func (m *UpdateKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeysResponse proto.InternalMessageInfo

func (m *UpdateKeysResponse) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *UpdateKeysResponse) GetAuthJWT() string {
	if m != nil {
		return m.AuthJWT
	}
	return ""
}

func (m *UpdateKeysResponse) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *UpdateKeysResponse) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *UpdateKeysResponse) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *UpdateKeysResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *UpdateKeysResponse) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type ListKeysRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query"`
}

func (m *ListKeysRequest) Reset()         { *m = ListKeysRequest{} }
func (m *ListKeysRequest) String() string { return proto.CompactTextString(m) }
func (*ListKeysRequest) ProtoMessage()    {}
func (*ListKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{6}
}
func (m *ListKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysRequest.Merge(m, src)
}
func (m *ListKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysRequest proto.InternalMessageInfo

func (m *ListKeysRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// ListKeysResponse holds all keys info
type ListKeysResponse struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Expiry          int64  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry"`
	AuthTTL         int64  `protobuf:"varint,3,opt,name=authTTL,proto3" json:"auth_ttl"`
	RefreshTTL      int64  `protobuf:"varint,4,opt,name=refreshTTL,proto3" json:"refresh_ttl"`
	RefreshStrategy string `protobuf:"bytes,5,opt,name=refreshStrategy,proto3" json:"refresh_strategy"`
	PubSigKey       []byte `protobuf:"bytes,6,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey       []byte `protobuf:"bytes,7,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Locked          bool   `protobuf:"varint,8,opt,name=locked,proto3" json:"locked"`
	Valid           bool   `protobuf:"varint,9,opt,name=valid,proto3" json:"valid"`
	Expired         bool   `protobuf:"varint,10,opt,name=expired,proto3" json:"expired"`
}

func (m *ListKeysResponse) Reset()         { *m = ListKeysResponse{} }
func (m *ListKeysResponse) String() string { return proto.CompactTextString(m) }
func (*ListKeysResponse) ProtoMessage()    {}
func (*ListKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{7}
}
func (m *ListKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysResponse.Merge(m, src)
}
func (m *ListKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysResponse proto.InternalMessageInfo

func (m *ListKeysResponse) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *ListKeysResponse) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *ListKeysResponse) GetAuthTTL() int64 {
	if m != nil {
		return m.AuthTTL
	}
	return 0
}

func (m *ListKeysResponse) GetRefreshTTL() int64 {
	if m != nil {
		return m.RefreshTTL
	}
	return 0
}

func (m *ListKeysResponse) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

func (m *ListKeysResponse) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *ListKeysResponse) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *ListKeysResponse) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

func (m *ListKeysResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *ListKeysResponse) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

type DelKeysRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *DelKeysRequest) Reset()         { *m = DelKeysRequest{} }
func (m *DelKeysRequest) String() string { return proto.CompactTextString(m) }
func (*DelKeysRequest) ProtoMessage()    {}
func (*DelKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{8}
}
func (m *DelKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelKeysRequest.Merge(m, src)
}
func (m *DelKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *DelKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DelKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DelKeysRequest proto.InternalMessageInfo

func (m *DelKeysRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type DelKeysResponse struct {
}

func (m *DelKeysResponse) Reset()         { *m = DelKeysResponse{} }
func (m *DelKeysResponse) String() string { return proto.CompactTextString(m) }
func (*DelKeysResponse) ProtoMessage()    {}
func (*DelKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{9}
}
func (m *DelKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelKeysResponse.Merge(m, src)
}
func (m *DelKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *DelKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DelKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DelKeysResponse proto.InternalMessageInfo

type PublicKeysRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *PublicKeysRequest) Reset()         { *m = PublicKeysRequest{} }
func (m *PublicKeysRequest) String() string { return proto.CompactTextString(m) }
func (*PublicKeysRequest) ProtoMessage()    {}
func (*PublicKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{10}
}
func (m *PublicKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeysRequest.Merge(m, src)
}
func (m *PublicKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeysRequest proto.InternalMessageInfo

func (m *PublicKeysRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type PublicKeysResponse struct {
	KID       string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	PubSigKey []byte `protobuf:"bytes,2,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey []byte `protobuf:"bytes,3,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Expiry    int64  `protobuf:"varint,4,opt,name=expiry,proto3" json:"expiry"`
	Valid     bool   `protobuf:"varint,5,opt,name=valid,proto3" json:"valid"`
}

func (m *PublicKeysResponse) Reset()         { *m = PublicKeysResponse{} }
func (m *PublicKeysResponse) String() string { return proto.CompactTextString(m) }
func (*PublicKeysResponse) ProtoMessage()    {}
func (*PublicKeysResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6196144d87d1119c, []int{11}
}
func (m *PublicKeysResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeysResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeysResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeysResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeysResponse.Merge(m, src)
}
func (m *PublicKeysResponse) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeysResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeysResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeysResponse proto.InternalMessageInfo

func (m *PublicKeysResponse) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *PublicKeysResponse) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *PublicKeysResponse) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *PublicKeysResponse) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *PublicKeysResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func init() {
	proto.RegisterType((*AuthRequest)(nil), "jwtis.services.keys.v1.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "jwtis.services.keys.v1.AuthResponse")
	proto.RegisterType((*RegisterRequest)(nil), "jwtis.services.keys.v1.RegisterRequest")
	proto.RegisterType((*RegisterResponse)(nil), "jwtis.services.keys.v1.RegisterResponse")
	proto.RegisterType((*UpdateKeysRequest)(nil), "jwtis.services.keys.v1.UpdateKeysRequest")
	proto.RegisterType((*UpdateKeysResponse)(nil), "jwtis.services.keys.v1.UpdateKeysResponse")
	proto.RegisterType((*ListKeysRequest)(nil), "jwtis.services.keys.v1.ListKeysRequest")
	proto.RegisterType((*ListKeysResponse)(nil), "jwtis.services.keys.v1.ListKeysResponse")
	proto.RegisterType((*DelKeysRequest)(nil), "jwtis.services.keys.v1.DelKeysRequest")
	proto.RegisterType((*DelKeysResponse)(nil), "jwtis.services.keys.v1.DelKeysResponse")
	proto.RegisterType((*PublicKeysRequest)(nil), "jwtis.services.keys.v1.PublicKeysRequest")
	proto.RegisterType((*PublicKeysResponse)(nil), "jwtis.services.keys.v1.PublicKeysResponse")
}

func init() { proto.RegisterFile("api/keys/v1/keys.proto", fileDescriptor_6196144d87d1119c) }

var fileDescriptor_6196144d87d1119c = []byte{
	// 880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0x8e, 0xd7, 0xfb, 0xf3, 0x25, 0xea, 0x26, 0x23, 0x1a, 0x2d, 0x7b, 0x58, 0x47, 0x06, 0xd2,
	0x80, 0x9a, 0x75, 0xba, 0x08, 0x24, 0x84, 0x84, 0xd4, 0x55, 0x91, 0x0a, 0xe9, 0x01, 0xdc, 0x20,
	0xa4, 0x4a, 0x28, 0xf2, 0x7a, 0xa7, 0xce, 0x74, 0x9d, 0xb5, 0xeb, 0x19, 0xa7, 0xf8, 0xbf, 0xe0,
	0xff, 0xe1, 0x50, 0x71, 0xe3, 0xd8, 0x23, 0x20, 0x64, 0xa1, 0xe4, 0xe6, 0xbf, 0x02, 0xcd, 0x78,
	0x1c, 0x7b, 0xbd, 0x71, 0xb3, 0x7b, 0xad, 0x7a, 0xc9, 0xac, 0x9f, 0xbf, 0x6f, 0x9e, 0xde, 0xf7,
	0xbe, 0x37, 0x19, 0xc3, 0xae, 0xe5, 0x13, 0x63, 0x86, 0x23, 0x6a, 0x5c, 0x3c, 0x10, 0xeb, 0xd0,
	0x0f, 0x3c, 0xe6, 0xa1, 0xdd, 0x17, 0xaf, 0x18, 0xa1, 0x43, 0x8a, 0x83, 0x0b, 0x62, 0x63, 0x3a,
	0x14, 0xaf, 0x2e, 0x1e, 0xf4, 0x0f, 0x1d, 0xc2, 0xce, 0xc2, 0xc9, 0xd0, 0xf6, 0xce, 0x0d, 0xc7,
	0x73, 0x3c, 0x43, 0xc0, 0x27, 0xe1, 0x73, 0xf1, 0x24, 0x1e, 0xc4, 0xaf, 0x74, 0x1b, 0xdd, 0x80,
	0xcd, 0x87, 0x21, 0x3b, 0x33, 0xf1, 0xcb, 0x10, 0x53, 0x86, 0xf6, 0x40, 0x9d, 0x91, 0x69, 0x4f,
	0xd9, 0x53, 0x0e, 0x3a, 0xe3, 0x3b, 0x97, 0xb1, 0xa6, 0x1e, 0x7f, 0xf7, 0x28, 0x89, 0x35, 0x1e,
	0x35, 0xf9, 0x1f, 0xfd, 0x4b, 0xd8, 0x4a, 0x09, 0xd4, 0xf7, 0xe6, 0x14, 0xa3, 0x7d, 0x68, 0x59,
	0x21, 0x3b, 0xfb, 0xfe, 0xe7, 0x13, 0xc9, 0xda, 0x4a, 0x62, 0xad, 0xcd, 0x43, 0xa7, 0x2f, 0x5e,
	0x31, 0x33, 0x7b, 0xa9, 0xff, 0xa3, 0x42, 0xd7, 0xc4, 0x0e, 0xa1, 0x0c, 0x07, 0x2b, 0x67, 0x43,
	0xf7, 0xa1, 0x89, 0x7f, 0xf5, 0x49, 0x10, 0xf5, 0x6a, 0x7b, 0xca, 0x81, 0x3a, 0xfe, 0x20, 0x89,
	0xb5, 0xed, 0x34, 0x72, 0xdf, 0x3b, 0x27, 0x0c, 0x9f, 0xfb, 0x2c, 0x32, 0x25, 0x06, 0x1d, 0x42,
	0x93, 0x12, 0xe7, 0xa1, 0xeb, 0xf4, 0x54, 0xb1, 0xe5, 0xdd, 0x24, 0xd6, 0x76, 0x28, 0x71, 0x4e,
	0x2d, 0xd7, 0x29, 0xc2, 0x53, 0x10, 0x3a, 0x82, 0x16, 0x25, 0xce, 0x98, 0x30, 0xda, 0xab, 0xef,
	0x29, 0x07, 0x8d, 0xf1, 0x6e, 0x12, 0x6b, 0x88, 0xe3, 0x27, 0x84, 0xd1, 0x02, 0x21, 0x83, 0xf1,
	0x04, 0x78, 0x6e, 0xf3, 0x04, 0x8d, 0x3c, 0x01, 0x9e, 0xdb, 0xe5, 0x04, 0x29, 0x88, 0x27, 0xc0,
	0x73, 0x5b, 0x24, 0x68, 0xe6, 0x09, 0x38, 0xbe, 0x9c, 0x40, 0xc2, 0x38, 0x83, 0x0b, 0x76, 0x72,
	0xf2, 0xa4, 0xd7, 0x12, 0x05, 0x0b, 0x86, 0x50, 0x93, 0x31, 0xb7, 0xc8, 0x90, 0x30, 0xf4, 0x15,
	0x40, 0x80, 0x9f, 0x07, 0x98, 0x0a, 0x52, 0x5b, 0x90, 0x3e, 0x4c, 0x62, 0xed, 0xae, 0x8c, 0x96,
	0x78, 0x05, 0x30, 0x7a, 0x0c, 0x5d, 0xf9, 0xf4, 0x94, 0x05, 0x16, 0xc3, 0x4e, 0xd4, 0xeb, 0x88,
	0xb2, 0x06, 0x49, 0xac, 0xf5, 0x33, 0x3e, 0x95, 0xef, 0x0a, 0x9b, 0x94, 0x69, 0xfa, 0xeb, 0x1a,
	0x6c, 0xe7, 0xcd, 0x95, 0xce, 0xb8, 0xbd, 0xbb, 0x05, 0xef, 0xd4, 0xde, 0xe2, 0x1d, 0x74, 0x08,
	0x1d, 0x3f, 0x9c, 0x3c, 0x25, 0xce, 0x31, 0x8e, 0x44, 0x6b, 0xb7, 0xc6, 0xdd, 0x24, 0xd6, 0x36,
	0xfd, 0x70, 0x72, 0xca, 0xdb, 0x35, 0xc3, 0x91, 0x99, 0x23, 0x24, 0xfc, 0xdb, 0xb9, 0xcd, 0xe1,
	0xf5, 0x45, 0x38, 0x17, 0x3f, 0x83, 0xa7, 0x08, 0xa4, 0x5f, 0x7b, 0xac, 0x21, 0xd4, 0x83, 0x24,
	0xd6, 0x64, 0xe4, 0xda, 0x59, 0x1a, 0x34, 0x2e, 0x2c, 0x97, 0x4c, 0x45, 0x1f, 0xdb, 0xe3, 0x4e,
	0x12, 0x6b, 0x69, 0xc0, 0x4c, 0x17, 0xf4, 0xcd, 0xb2, 0x96, 0x2d, 0x51, 0x92, 0x70, 0x6c, 0x59,
	0xcb, 0x65, 0x05, 0xff, 0x55, 0x61, 0xe7, 0x27, 0x7f, 0x6a, 0x31, 0x7c, 0x8c, 0x23, 0xfa, 0x7e,
	0x40, 0xde, 0xb1, 0x01, 0xf9, 0xa3, 0x06, 0xa8, 0xd8, 0xde, 0xf7, 0x23, 0xb2, 0xfe, 0x88, 0x8c,
	0xa0, 0xfb, 0x84, 0x50, 0x56, 0x9c, 0x0f, 0x0d, 0x1a, 0x2f, 0x43, 0x1c, 0x44, 0x52, 0x41, 0x91,
	0x53, 0x04, 0xcc, 0x74, 0xd1, 0x7f, 0x57, 0x61, 0x3b, 0x27, 0xad, 0xac, 0xba, 0x5e, 0x9a, 0xaa,
	0x9b, 0xea, 0xdd, 0xcf, 0x9d, 0xa8, 0x0a, 0x50, 0xde, 0x19, 0xc6, 0xdc, 0xdc, 0x7f, 0xc6, 0x82,
	0xff, 0xea, 0x02, 0x2a, 0xb4, 0x2e, 0xf8, 0x6f, 0xc1, 0x75, 0x37, 0xe8, 0xd4, 0x58, 0x43, 0xa7,
	0x45, 0x2b, 0x34, 0xd7, 0xb3, 0x42, 0x6b, 0x15, 0x2b, 0xb8, 0x9e, 0x3d, 0xc3, 0x53, 0x31, 0x4a,
	0xed, 0x54, 0x9a, 0x34, 0x62, 0xca, 0x35, 0xb7, 0x42, 0xa7, 0xc2, 0x0a, 0x9f, 0x40, 0x4b, 0xa8,
	0x88, 0xa7, 0x3d, 0x10, 0x90, 0xcd, 0x24, 0xd6, 0xb2, 0x90, 0x99, 0xfd, 0xd0, 0x47, 0x70, 0xe7,
	0x11, 0x76, 0xd7, 0x3a, 0x10, 0xf5, 0x1d, 0xe8, 0x5e, 0x73, 0xd2, 0x7e, 0xeb, 0x5f, 0xc0, 0xce,
	0x0f, 0xe1, 0xc4, 0x25, 0xf6, 0x7a, 0x3b, 0xfd, 0xad, 0x00, 0x2a, 0xf2, 0x56, 0x76, 0xcf, 0x42,
	0x03, 0x6a, 0xeb, 0x35, 0x40, 0x5d, 0x63, 0x16, 0xeb, 0xb7, 0xcf, 0x62, 0xe3, 0xe6, 0x06, 0x8c,
	0x5e, 0xd7, 0xa1, 0xce, 0xab, 0x42, 0x3f, 0x42, 0x9d, 0x5f, 0xe7, 0xd0, 0x47, 0xc3, 0x9b, 0xef,
	0x93, 0xc3, 0xc2, 0xed, 0xb0, 0xff, 0xf1, 0xdb, 0x41, 0x52, 0xa0, 0x5f, 0xa0, 0x9d, 0xdd, 0x05,
	0xd0, 0xbd, 0x2a, 0x46, 0xe9, 0x2a, 0xd8, 0x3f, 0xb8, 0x1d, 0x28, 0xb7, 0xb7, 0x01, 0xf2, 0x93,
	0x14, 0x7d, 0x5a, 0xc5, 0x5b, 0xfa, 0x67, 0xda, 0xff, 0x6c, 0x15, 0xa8, 0x4c, 0x72, 0x0a, 0xed,
	0xec, 0xd8, 0xa8, 0xae, 0xa1, 0x74, 0x1a, 0x55, 0xd7, 0x50, 0x3e, 0x81, 0x8e, 0x14, 0xf4, 0x0c,
	0x5a, 0xd2, 0xa6, 0x68, 0xbf, 0x8a, 0xb6, 0xe8, 0xfd, 0xfe, 0xbd, 0x5b, 0x71, 0xb9, 0x42, 0xb9,
	0x6f, 0xab, 0x15, 0x5a, 0x9a, 0x89, 0x6a, 0x85, 0x96, 0xc7, 0x60, 0xfc, 0xf8, 0xcf, 0xcb, 0x81,
	0xf2, 0xe6, 0x72, 0xa0, 0xfc, 0x77, 0x39, 0x50, 0x7e, 0xbb, 0x1a, 0x6c, 0xbc, 0xb9, 0x1a, 0x6c,
	0xfc, 0x75, 0x35, 0xd8, 0x78, 0x36, 0x2c, 0x7c, 0x81, 0xcc, 0xac, 0xc0, 0x9a, 0x33, 0x32, 0x1f,
	0x1d, 0x8d, 0x8e, 0x0c, 0xb1, 0xb9, 0x51, 0xf8, 0x9e, 0xf9, 0x9a, 0xaf, 0x93, 0xa6, 0xf8, 0x12,
	0xf9, 0xfc, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x0a, 0x85, 0x5d, 0xea, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KeysClient is the client API for Keys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KeysClient interface {
	Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	UpdateKeys(ctx context.Context, in *UpdateKeysRequest, opts ...grpc.CallOption) (*UpdateKeysResponse, error)
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (Keys_ListKeysClient, error)
	DelKeys(ctx context.Context, in *DelKeysRequest, opts ...grpc.CallOption) (*DelKeysResponse, error)
	PublicKeys(ctx context.Context, in *PublicKeysRequest, opts ...grpc.CallOption) (*PublicKeysResponse, error)
}

type keysClient struct {
	cc *grpc.ClientConn
}

func NewKeysClient(cc *grpc.ClientConn) KeysClient {
	return &keysClient{cc}
}

func (c *keysClient) Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, "/jwtis.services.keys.v1.Keys/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, "/jwtis.services.keys.v1.Keys/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) UpdateKeys(ctx context.Context, in *UpdateKeysRequest, opts ...grpc.CallOption) (*UpdateKeysResponse, error) {
	out := new(UpdateKeysResponse)
	err := c.cc.Invoke(ctx, "/jwtis.services.keys.v1.Keys/UpdateKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (Keys_ListKeysClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[0], "/jwtis.services.keys.v1.Keys/ListKeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysListKeysClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Keys_ListKeysClient interface {
	Recv() (*ListKeysResponse, error)
	grpc.ClientStream
}

type keysListKeysClient struct {
	grpc.ClientStream
}

func (x *keysListKeysClient) Recv() (*ListKeysResponse, error) {
	m := new(ListKeysResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) DelKeys(ctx context.Context, in *DelKeysRequest, opts ...grpc.CallOption) (*DelKeysResponse, error) {
	out := new(DelKeysResponse)
	err := c.cc.Invoke(ctx, "/jwtis.services.keys.v1.Keys/DelKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) PublicKeys(ctx context.Context, in *PublicKeysRequest, opts ...grpc.CallOption) (*PublicKeysResponse, error) {
	out := new(PublicKeysResponse)
	err := c.cc.Invoke(ctx, "/jwtis.services.keys.v1.Keys/PublicKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeysServer is the server API for Keys service.
type KeysServer interface {
	Auth(context.Context, *AuthRequest) (*AuthResponse, error)
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	UpdateKeys(context.Context, *UpdateKeysRequest) (*UpdateKeysResponse, error)
	ListKeys(*ListKeysRequest, Keys_ListKeysServer) error
	DelKeys(context.Context, *DelKeysRequest) (*DelKeysResponse, error)
	PublicKeys(context.Context, *PublicKeysRequest) (*PublicKeysResponse, error)
}

// UnimplementedKeysServer can be embedded to have forward compatible implementations.
type UnimplementedKeysServer struct {
}

func (*UnimplementedKeysServer) Auth(ctx context.Context, req *AuthRequest) (*AuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (*UnimplementedKeysServer) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedKeysServer) UpdateKeys(ctx context.Context, req *UpdateKeysRequest) (*UpdateKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeys not implemented")
}
func (*UnimplementedKeysServer) ListKeys(req *ListKeysRequest, srv Keys_ListKeysServer) error {
	return status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}
func (*UnimplementedKeysServer) DelKeys(ctx context.Context, req *DelKeysRequest) (*DelKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKeys not implemented")
}
func (*UnimplementedKeysServer) PublicKeys(ctx context.Context, req *PublicKeysRequest) (*PublicKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKeys not implemented")
}

func RegisterKeysServer(s *grpc.Server, srv KeysServer) {
	s.RegisterService(&_Keys_serviceDesc, srv)
}

func _Keys_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jwtis.services.keys.v1.Keys/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Auth(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jwtis.services.keys.v1.Keys/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_UpdateKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).UpdateKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jwtis.services.keys.v1.Keys/UpdateKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).UpdateKeys(ctx, req.(*UpdateKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ListKeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListKeysRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeysServer).ListKeys(m, &keysListKeysServer{stream})
}

type Keys_ListKeysServer interface {
	Send(*ListKeysResponse) error
	grpc.ServerStream
}

type keysListKeysServer struct {
	grpc.ServerStream
}

func (x *keysListKeysServer) Send(m *ListKeysResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Keys_DelKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).DelKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jwtis.services.keys.v1.Keys/DelKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).DelKeys(ctx, req.(*DelKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_PublicKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).PublicKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jwtis.services.keys.v1.Keys/PublicKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).PublicKeys(ctx, req.(*PublicKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Keys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jwtis.services.keys.v1.Keys",
	HandlerType: (*KeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Auth",
			Handler:    _Keys_Auth_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Keys_Register_Handler,
		},
		{
			MethodName: "UpdateKeys",
			Handler:    _Keys_UpdateKeys_Handler,
		},
		{
			MethodName: "DelKeys",
			Handler:    _Keys_DelKeys_Handler,
		},
		{
			MethodName: "PublicKeys",
			Handler:    _Keys_PublicKeys_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListKeys",
			Handler:       _Keys_ListKeys_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/keys/v1/keys.proto",
}

func (m *AuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthJWT) > 0 {
		i -= len(m.AuthJWT)
		copy(dAtA[i:], m.AuthJWT)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.AuthJWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RefreshTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.RefreshTTL))
		i--
		dAtA[i] = 0x40
	}
	if m.AuthTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.AuthTTL))
		i--
		dAtA[i] = 0x38
	}
	if m.EncBits != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.EncBits))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EncAlg) > 0 {
		i -= len(m.EncAlg)
		copy(dAtA[i:], m.EncAlg)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.EncAlg)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SigBits != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.SigBits))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SigAlg) > 0 {
		i -= len(m.SigAlg)
		copy(dAtA[i:], m.SigAlg)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.SigAlg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthJWT) > 0 {
		i -= len(m.AuthJWT)
		copy(dAtA[i:], m.AuthJWT)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.AuthJWT)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RefreshTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.RefreshTTL))
		i--
		dAtA[i] = 0x40
	}
	if m.AuthTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.AuthTTL))
		i--
		dAtA[i] = 0x38
	}
	if m.EncBits != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.EncBits))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EncAlg) > 0 {
		i -= len(m.EncAlg)
		copy(dAtA[i:], m.EncAlg)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.EncAlg)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SigBits != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.SigBits))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SigAlg) > 0 {
		i -= len(m.SigAlg)
		copy(dAtA[i:], m.SigAlg)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.SigAlg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthJWT) > 0 {
		i -= len(m.AuthJWT)
		copy(dAtA[i:], m.AuthJWT)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.AuthJWT)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired {
		i--
		if m.Expired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefreshTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.RefreshTTL))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthTTL != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.AuthTTL))
		i--
		dAtA[i] = 0x18
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PublicKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKeysResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeysResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeysResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Expiry != 0 {
		i = encodeVarintKeys(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintKeys(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintKeys(dAtA []byte, offset int, v uint64) int {
	offset -= sovKeys(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *AuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthJWT)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *RegisterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	l = len(m.SigAlg)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.SigBits != 0 {
		n += 1 + sovKeys(uint64(m.SigBits))
	}
	l = len(m.EncAlg)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.EncBits != 0 {
		n += 1 + sovKeys(uint64(m.EncBits))
	}
	if m.AuthTTL != 0 {
		n += 1 + sovKeys(uint64(m.AuthTTL))
	}
	if m.RefreshTTL != 0 {
		n += 1 + sovKeys(uint64(m.RefreshTTL))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *RegisterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.AuthJWT)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	if m.Valid {
		n += 2
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *UpdateKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	l = len(m.SigAlg)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.SigBits != 0 {
		n += 1 + sovKeys(uint64(m.SigBits))
	}
	l = len(m.EncAlg)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.EncBits != 0 {
		n += 1 + sovKeys(uint64(m.EncBits))
	}
	if m.AuthTTL != 0 {
		n += 1 + sovKeys(uint64(m.AuthTTL))
	}
	if m.RefreshTTL != 0 {
		n += 1 + sovKeys(uint64(m.RefreshTTL))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *UpdateKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.AuthJWT)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	if m.Valid {
		n += 2
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *ListKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *ListKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	if m.AuthTTL != 0 {
		n += 1 + sovKeys(uint64(m.AuthTTL))
	}
	if m.RefreshTTL != 0 {
		n += 1 + sovKeys(uint64(m.RefreshTTL))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Locked {
		n += 2
	}
	if m.Valid {
		n += 2
	}
	if m.Expired {
		n += 2
	}
	return n
}

func (m *DelKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *DelKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PublicKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	return n
}

func (m *PublicKeysResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovKeys(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovKeys(uint64(m.Expiry))
	}
	if m.Valid {
		n += 2
	}
	return n
}

func sovKeys(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozKeys(x uint64) (n int) {
	return sovKeys(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthJWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthJWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigBits", wireType)
			}
			m.SigBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncBits", wireType)
			}
			m.EncBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTTL", wireType)
			}
			m.AuthTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTTL", wireType)
			}
			m.RefreshTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthJWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthJWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigBits", wireType)
			}
			m.SigBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncBits", wireType)
			}
			m.EncBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTTL", wireType)
			}
			m.AuthTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTTL", wireType)
			}
			m.RefreshTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthJWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthJWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTTL", wireType)
			}
			m.AuthTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTTL", wireType)
			}
			m.RefreshTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeysResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeysResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeysResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeys
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeys
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKeys(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKeys
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeys
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKeys
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupKeys
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthKeys
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthKeys        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKeys          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupKeys = fmt.Errorf("proto: unexpected end of group")
)
