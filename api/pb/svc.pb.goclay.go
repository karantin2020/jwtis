// Code generated by protoc-gen-goclay. DO NOT EDIT.
// source: api/pb/svc.proto

/*
Package jwtispb is a self-registering gRPC and JSON+Swagger service definition.

It conforms to the github.com/utrack/clay/v2/transport Service interface.
*/
package jwtispb

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-chi/chi"
	"github.com/go-chi/render"
	"github.com/go-openapi/spec"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
	"github.com/karantin2020/errorpb"
	"github.com/pkg/errors"
	"github.com/utrack/clay/transport"
	"github.com/utrack/clay/transport/httpclient"
	"github.com/utrack/clay/transport/httpruntime"
	"github.com/utrack/clay/transport/httpruntime/httpmw"
	"github.com/utrack/clay/transport/httptransport"
	"github.com/utrack/clay/transport/swagger"
	"google.golang.org/grpc"
)

// Update your shared lib or downgrade generator to v1 if there's an error
var _ = transport.IsVersion2

var _ = ioutil.Discard
var _ chi.Router
var _ runtime.Marshaler
var _ bytes.Buffer
var _ context.Context
var _ fmt.Formatter
var _ strings.Reader
var _ errors.Frame
var _ httpruntime.Marshaler
var _ http.Handler
var _ url.Values
var _ base64.Encoding
var _ httptransport.MarshalerError
var _ utilities.DoubleArray

// JWTISDesc is a descriptor/registrator for the JWTISServer.
type JWTISDesc struct {
	svc  JWTISServer
	opts httptransport.DescOptions
}

// NewJWTISServiceDesc creates new registrator for the JWTISServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewJWTISServiceDesc(svc JWTISServer) *JWTISDesc {
	return &JWTISDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *JWTISDesc) RegisterGRPC(s *grpc.Server) {
	RegisterJWTISServer(s, d.svc)
}

// Apply applies passed options.
func (d *JWTISDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *JWTISDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_api_pb_svc_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_api_pb_svc_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *JWTISDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for NewJWT, binding: POST /api/v1/newjwt
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_NewJWT_0(r)
			rsp, err := _JWTIS_NewJWT_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_JWTIS_NewJWT_0, h)
		} else {
			mux.Handle(pattern_goclay_JWTIS_NewJWT_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for RenewJWT, binding: POST /api/v1/renewjwt
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_RenewJWT_0(r)
			rsp, err := _JWTIS_RenewJWT_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_JWTIS_RenewJWT_0, h)
		} else {
			mux.Handle(pattern_goclay_JWTIS_RenewJWT_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for Register, binding: POST /api/v1/register
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_Register_0(r)
			rsp, err := _JWTIS_Register_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_JWTIS_Register_0, h)
		} else {
			mux.Handle(pattern_goclay_JWTIS_Register_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UpdateKeys, binding: PUT /api/v1/keys/{kid}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_UpdateKeys_0(r)
			rsp, err := _JWTIS_UpdateKeys_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("PUT", pattern_goclay_JWTIS_UpdateKeys_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for DelKeys, binding: DELETE /api/v1/keys/{kid}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_DelKeys_0(r)
			rsp, err := _JWTIS_DelKeys_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("DELETE", pattern_goclay_JWTIS_DelKeys_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for PublicKeys, binding: POST /api/v1/keys/{kid}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_JWTIS_PublicKeys_0(r)
			rsp, err := _JWTIS_PublicKeys_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					errorpb.WriteError(r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				errorpb.WriteError(r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			render.JSON(w, r, rsp)
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_JWTIS_PublicKeys_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

}

type JWTIS_httpClient struct {
	c    *http.Client
	host string
}

// NewJWTISHTTPClient creates new HTTP client for JWTISServer.
// Pass addr in format "http://host[:port]".
func NewJWTISHTTPClient(c *http.Client, addr string) *JWTIS_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &JWTIS_httpClient{c: c, host: addr}
}

func (c *JWTIS_httpClient) NewJWT(ctx context.Context, in *NewTokenRequest, opts ...grpc.CallOption) (*TokenResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_NewJWT_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &TokenResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *JWTIS_httpClient) RenewJWT(ctx context.Context, in *RenewTokenRequest, opts ...grpc.CallOption) (*TokenResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_RenewJWT_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &TokenResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *JWTIS_httpClient) Register(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_Register_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &RegisterClientResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *JWTIS_httpClient) UpdateKeys(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_UpdateKeys_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("PUT", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &RegisterClientResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *JWTIS_httpClient) DelKeys(ctx context.Context, in *DelKeysRequest, opts ...grpc.CallOption) (*DelKeysResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_DelKeys_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("DELETE", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &DelKeysResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *JWTIS_httpClient) PublicKeys(ctx context.Context, in *PubKeysRequest, opts ...grpc.CallOption) (*PubKeysResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_JWTIS_PublicKeys_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &PubKeysResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

// patterns for JWTIS
var (
	pattern_goclay_JWTIS_NewJWT_0 = "/api/v1/newjwt"

	pattern_goclay_JWTIS_NewJWT_0_builder = func(in *NewTokenRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/newjwt"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_NewJWT_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_JWTIS_RenewJWT_0 = "/api/v1/renewjwt"

	pattern_goclay_JWTIS_RenewJWT_0_builder = func(in *RenewTokenRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/renewjwt"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_RenewJWT_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_JWTIS_Register_0 = "/api/v1/register"

	pattern_goclay_JWTIS_Register_0_builder = func(in *RegisterClientRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/register"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_Register_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_JWTIS_UpdateKeys_0 = "/api/v1/keys/{kid}"

	pattern_goclay_JWTIS_UpdateKeys_0_builder = func(in *RegisterClientRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/keys/%v", in.Kid),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_UpdateKeys_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0, "kid": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}

	pattern_goclay_JWTIS_DelKeys_0 = "/api/v1/keys/{kid}"

	pattern_goclay_JWTIS_DelKeys_0_builder = func(in *DelKeysRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/keys/%v", in.Kid),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_DelKeys_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"kid": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_JWTIS_PublicKeys_0 = "/api/v1/keys/{kid}"

	pattern_goclay_JWTIS_PublicKeys_0_builder = func(in *PubKeysRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/api/v1/keys/%v", in.Kid),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_JWTIS_PublicKeys_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0, "kid": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

// marshalers for JWTIS
var (
	unmarshaler_goclay_JWTIS_NewJWT_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*NewTokenRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_NewJWT_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			if err := errors.Wrap(render.Decode(r, req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_JWTIS_RenewJWT_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*RenewTokenRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_RenewJWT_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			if err := errors.Wrap(render.Decode(r, req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_JWTIS_Register_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*RegisterClientRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_Register_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			if err := errors.Wrap(render.Decode(r, req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_JWTIS_UpdateKeys_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*RegisterClientRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_UpdateKeys_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			if err := errors.Wrap(render.Decode(r, req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_JWTIS_DelKeys_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*DelKeysRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_DelKeys_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_JWTIS_PublicKeys_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*PubKeysRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_JWTIS_PublicKeys_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			if err := errors.Wrap(render.Decode(r, req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}
)

var _swaggerDef_api_pb_svc_proto = []byte(`{
  "swagger": "2.0",
  "info": {
    "title": "JWTIS service",
    "version": "0.1.1",
    "contact": {
      "name": "JWTIS",
      "url": "https://github.com/karantin2020/jwtis"
    }
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/keys/{kid}": {
      "delete": {
        "operationId": "DelKeys",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbDelKeysResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "kid",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "JWTIS"
        ]
      },
      "post": {
        "operationId": "PublicKeys",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbPubKeysResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "kid",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jwtispbPubKeysRequest"
            }
          }
        ],
        "tags": [
          "JWTIS"
        ]
      },
      "put": {
        "operationId": "UpdateKeys",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbRegisterClientResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "kid",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jwtispbRegisterClientRequest"
            }
          }
        ],
        "tags": [
          "JWTIS"
        ]
      }
    },
    "/api/v1/newjwt": {
      "post": {
        "summary": "Summary: New JWT token",
        "description": "Issue new JWT token",
        "operationId": "NewJWT",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbTokenResponse"
            }
          },
          "400": {
            "description": "Returned when invalid request data sent",
            "schema": {}
          },
          "404": {
            "description": "Returned when crypto keys not found",
            "schema": {}
          },
          "500": {
            "description": "Returned when internal server error have got",
            "schema": {}
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jwtispbNewTokenRequest"
            }
          }
        ],
        "tags": [
          "JWTIS"
        ]
      }
    },
    "/api/v1/register": {
      "post": {
        "operationId": "Register",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbRegisterClientResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jwtispbRegisterClientRequest"
            }
          }
        ],
        "tags": [
          "JWTIS"
        ]
      }
    },
    "/api/v1/renewjwt": {
      "post": {
        "summary": "Summary: Renew JWT token",
        "description": "Renew JWT token",
        "operationId": "RenewJWT",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jwtispbTokenResponse"
            }
          },
          "403": {
            "description": "Returned when invalid crypto primitives exist",
            "schema": {}
          },
          "404": {
            "description": "Returned when crypto keys not found",
            "schema": {}
          },
          "409": {
            "description": "Returned when refresh token expired",
            "schema": {}
          },
          "422": {
            "description": "Returned when invalid refresh claims sent",
            "schema": {}
          },
          "500": {
            "description": "Returned when internal server error have got",
            "schema": {}
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jwtispbRenewTokenRequest"
            }
          }
        ],
        "tags": [
          "JWTIS"
        ]
      }
    }
  },
  "definitions": {
    "jwtispbDelKeysResponse": {
      "type": "object",
      "title": "DelKeysResponse as empty struct"
    },
    "jwtispbNewTokenRequest": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        },
        "claims": {
          "type": "string"
        }
      },
      "title": "NewTokenRequest contains new token info"
    },
    "jwtispbPubKeysRequest": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        }
      },
      "title": "PubKeysRequest fetch public keys"
    },
    "jwtispbPubKeysResponse": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        },
        "pubSigKey": {
          "type": "string",
          "format": "byte"
        },
        "pubEncKey": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PubKeysResponse holds public keys"
    },
    "jwtispbRegisterClientRequest": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        },
        "expiry": {
          "type": "string",
          "format": "int64"
        },
        "sigAlg": {
          "type": "string"
        },
        "sigBits": {
          "type": "integer",
          "format": "int32"
        },
        "encAlg": {
          "type": "string"
        },
        "encBits": {
          "type": "integer",
          "format": "int32"
        },
        "authTTL": {
          "type": "string",
          "format": "int64"
        },
        "refreshTTL": {
          "type": "string",
          "format": "int64"
        },
        "refreshStrategy": {
          "type": "string",
          "title": "RefreshStrategy is used in RenewJWT to decide wheather to issue new refresh token\nwith access token or not\nthis option applies to all renewJWT requests"
        }
      },
      "title": "RegisterClientRequest sent to jwtis to register new client"
    },
    "jwtispbRegisterClientResponse": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        },
        "clientToken": {
          "type": "string"
        },
        "pubSigKey": {
          "type": "string",
          "format": "byte"
        },
        "pubEncKey": {
          "type": "string",
          "format": "byte"
        },
        "expiry": {
          "type": "string",
          "format": "int64"
        },
        "valid": {
          "type": "boolean",
          "format": "boolean"
        }
      },
      "title": "RegisterClientResponse sent to client after it's registration"
    },
    "jwtispbRenewTokenRequest": {
      "type": "object",
      "properties": {
        "kid": {
          "type": "string"
        },
        "refreshToken": {
          "type": "string"
        },
        "refreshStrategy": {
          "type": "string"
        }
      },
      "title": "RenewTokenRequest contains renew token info"
    },
    "jwtispbTokenResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string"
        },
        "accessToken": {
          "type": "string"
        },
        "refreshToken": {
          "type": "string"
        },
        "expiry": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "TokenResponse is sent for any token request"
    }
  }
}

`)
