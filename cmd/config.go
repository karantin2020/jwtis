package main

import (
	"log"
	"os"

	cli "github.com/jawher/mow.cli"
	"github.com/karantin2020/jwtis"
)

// http config
type httpConf struct {
	listen *string // ip:port to listen to
	tls    *bool   // Future feature
}

// Default keys generation options
type sign struct {
	sigAlg  *string // Default algorithn to be used for sign
	sigBits *int    // Default key size in bits for sign
}
type encryption struct {
	encAlg  *string // Default algorithn to be used for encrypt
	encBits *int    // Default key size in bits for encrypt
}
type keyGeneration struct {
	// keys generation options
	sign
	encryption
	// Key IDs
	kid *string // Key ID
}
type options struct {
	httpConf
	keyGeneration
	selfName *string // Name of this service

	// internal options
	dbPath *string
}

type bootstrapOptions struct {
	password string // Storage password generated by this app
	dbExists bool
}

var (
	conf          options
	bootstrapConf bootstrapOptions
)

const (
	dbPathName = "keys_db" // default db folder name
)

func newConfigApp() *cli.Cli {
	app := cli.App(appName, appDescription)
	app.Version("v version", appVersion)
	app.Spec = "[OPTIONS]"
	conf = options{
		httpConf: httpConf{
			listen: app.String(cli.StringOpt{
				Name:   "l listen",
				Value:  "127.0.0.1:4343",
				Desc:   "ip:port to listen to",
				EnvVar: envPrefix + "ADDRESS",
			}),
			tls: app.Bool(cli.BoolOpt{
				Name:   "tls",
				Value:  false,
				Desc:   "Use tls connection [not implemented yet]",
				EnvVar: envPrefix + "TLS",
			}),
		},
		keyGeneration: keyGeneration{
			// keys generation options
			sign: sign{
				sigAlg: app.String(cli.StringOpt{
					Name:   "sigAlg",
					Value:  "RS256",
					Desc:   "Default algorithn to be used for sign",
					EnvVar: envPrefix + "SIG_ALG",
				}),
				sigBits: app.Int(cli.IntOpt{
					Name:   "sigBits",
					Value:  2048,
					Desc:   "Default key size in bits for sign key",
					EnvVar: envPrefix + "SIG_BITS",
				}),
			},
			encryption: encryption{
				encAlg: app.String(cli.StringOpt{
					Name:   "encAlg",
					Value:  "RSA-OAEP-256",
					Desc:   "Default algorithn to be used for encrypt",
					EnvVar: envPrefix + "ENC_ALG",
				}),
				encBits: app.Int(cli.IntOpt{
					Name:   "encBits",
					Value:  2048,
					Desc:   "Default key size in bits for encrypt",
					EnvVar: envPrefix + "ENC_BITS",
				}),
			},
			kid: app.String(cli.StringOpt{
				Name:   "k kid",
				Value:  "",
				Desc:   "Key ID to set to enc ang sign keys",
				EnvVar: envPrefix + "KEY_ID",
			}),
		},
		selfName: app.String(cli.StringOpt{
			Name:   "n name",
			Value:  "JWTIS",
			Desc:   "Name of this service",
			EnvVar: envPrefix + "NAME",
		}),
		dbPath: app.String(cli.StringOpt{
			Name:   "p dbPath",
			Value:  "./data/" + dbPathName,
			Desc:   "Path to store keys db",
			EnvVar: envPrefix + "DB_PATH",
		}),
	}
	checkDbPath()
	if err := conf.validate(); err != nil {
		log.Printf("Invalid options:\n%s\n", err.Error())
		app.PrintLongHelp()
		cli.Exit(1)
	}
	return app
}

func (o options) validate() error {
	return nil
}

func checkDbPath() {
	if info, err := os.Stat(*conf.dbPath); !os.IsNotExist(err) {
		if !info.IsDir() {
			FatalF("Db path exists and it is not a folder, must be folder")
		}
	} else {
		if err := os.MkdirAll(*conf.dbPath, os.ModePerm); err != nil {
			FatalF("Couldn't make db dir. Reason: %s", err.Error())
		}
	}
}

// password: getPassword(passwordLength), // Storage password generated by this app
func getPassword(length int) string {
	numtries := 5
	var (
		err    error
		secret []byte
	)
	for secret, err = jwtis.GenerateSecret(length); err != nil; numtries-- {
		if numtries == 0 {
			FatalF("Couldn't generate secret key because of internal problem")
		}
	}
	return string(secret)
}

func FatalF(format string, v ...interface{}) {
	log.Printf(format, v...)
	cli.Exit(1)
}
