// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: jwtis.proto

package pb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NewJWTRequest struct {
	KID    string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Claims []byte `protobuf:"bytes,2,opt,name=claims,proto3" json:"claims,omitempty"`
}

func (m *NewJWTRequest) Reset()         { *m = NewJWTRequest{} }
func (m *NewJWTRequest) String() string { return proto.CompactTextString(m) }
func (*NewJWTRequest) ProtoMessage()    {}
func (*NewJWTRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{0}
}
func (m *NewJWTRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewJWTRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewJWTRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewJWTRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewJWTRequest.Merge(m, src)
}
func (m *NewJWTRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewJWTRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewJWTRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewJWTRequest proto.InternalMessageInfo

func (m *NewJWTRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *NewJWTRequest) GetClaims() []byte {
	if m != nil {
		return m.Claims
	}
	return nil
}

type NewJWTReply struct {
	ID           string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	AccessToken  string `protobuf:"bytes,2,opt,name=accessToken,proto3" json:"access_token"`
	RefreshToken string `protobuf:"bytes,3,opt,name=refreshToken,proto3" json:"refresh_token"`
	Expiry       int64  `protobuf:"varint,4,opt,name=expiry,proto3" json:"expiry"`
}

func (m *NewJWTReply) Reset()         { *m = NewJWTReply{} }
func (m *NewJWTReply) String() string { return proto.CompactTextString(m) }
func (*NewJWTReply) ProtoMessage()    {}
func (*NewJWTReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{1}
}
func (m *NewJWTReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewJWTReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewJWTReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewJWTReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewJWTReply.Merge(m, src)
}
func (m *NewJWTReply) XXX_Size() int {
	return m.Size()
}
func (m *NewJWTReply) XXX_DiscardUnknown() {
	xxx_messageInfo_NewJWTReply.DiscardUnknown(m)
}

var xxx_messageInfo_NewJWTReply proto.InternalMessageInfo

func (m *NewJWTReply) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *NewJWTReply) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *NewJWTReply) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *NewJWTReply) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type RenewJWTRequest struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	RefreshToken    string `protobuf:"bytes,2,opt,name=refreshToken,proto3" json:"refresh_token"`
	RefreshStrategy string `protobuf:"bytes,3,opt,name=refreshStrategy,proto3" json:"refresh_strategy,omitempty"`
}

func (m *RenewJWTRequest) Reset()         { *m = RenewJWTRequest{} }
func (m *RenewJWTRequest) String() string { return proto.CompactTextString(m) }
func (*RenewJWTRequest) ProtoMessage()    {}
func (*RenewJWTRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{2}
}
func (m *RenewJWTRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewJWTRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewJWTRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewJWTRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewJWTRequest.Merge(m, src)
}
func (m *RenewJWTRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenewJWTRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewJWTRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenewJWTRequest proto.InternalMessageInfo

func (m *RenewJWTRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RenewJWTRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *RenewJWTRequest) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type RenewJWTReply struct {
}

func (m *RenewJWTReply) Reset()         { *m = RenewJWTReply{} }
func (m *RenewJWTReply) String() string { return proto.CompactTextString(m) }
func (*RenewJWTReply) ProtoMessage()    {}
func (*RenewJWTReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{3}
}
func (m *RenewJWTReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewJWTReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewJWTReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewJWTReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewJWTReply.Merge(m, src)
}
func (m *RenewJWTReply) XXX_Size() int {
	return m.Size()
}
func (m *RenewJWTReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewJWTReply.DiscardUnknown(m)
}

var xxx_messageInfo_RenewJWTReply proto.InternalMessageInfo

type RevokeJWTRequest struct {
	KID          string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	ID           string `protobuf:"bytes,2,opt,name=id,proto3" json:"id"`
	RefreshToken string `protobuf:"bytes,3,opt,name=refreshToken,proto3" json:"refresh_token"`
}

func (m *RevokeJWTRequest) Reset()         { *m = RevokeJWTRequest{} }
func (m *RevokeJWTRequest) String() string { return proto.CompactTextString(m) }
func (*RevokeJWTRequest) ProtoMessage()    {}
func (*RevokeJWTRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{4}
}
func (m *RevokeJWTRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokeJWTRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevokeJWTRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevokeJWTRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeJWTRequest.Merge(m, src)
}
func (m *RevokeJWTRequest) XXX_Size() int {
	return m.Size()
}
func (m *RevokeJWTRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeJWTRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeJWTRequest proto.InternalMessageInfo

func (m *RevokeJWTRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RevokeJWTRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *RevokeJWTRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type RevokeJWTReply struct {
}

func (m *RevokeJWTReply) Reset()         { *m = RevokeJWTReply{} }
func (m *RevokeJWTReply) String() string { return proto.CompactTextString(m) }
func (*RevokeJWTReply) ProtoMessage()    {}
func (*RevokeJWTReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{5}
}
func (m *RevokeJWTReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokeJWTReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevokeJWTReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevokeJWTReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeJWTReply.Merge(m, src)
}
func (m *RevokeJWTReply) XXX_Size() int {
	return m.Size()
}
func (m *RevokeJWTReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeJWTReply.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeJWTReply proto.InternalMessageInfo

type AuthRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *AuthRequest) Reset()         { *m = AuthRequest{} }
func (m *AuthRequest) String() string { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()    {}
func (*AuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{6}
}
func (m *AuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthRequest.Merge(m, src)
}
func (m *AuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthRequest proto.InternalMessageInfo

func (m *AuthRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type AuthReply struct {
	// JWT that can be used for authz
	AuthJWT string `protobuf:"bytes,1,opt,name=authJWT,proto3" json:"auth_jwt"`
}

func (m *AuthReply) Reset()         { *m = AuthReply{} }
func (m *AuthReply) String() string { return proto.CompactTextString(m) }
func (*AuthReply) ProtoMessage()    {}
func (*AuthReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{7}
}
func (m *AuthReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthReply.Merge(m, src)
}
func (m *AuthReply) XXX_Size() int {
	return m.Size()
}
func (m *AuthReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthReply.DiscardUnknown(m)
}

var xxx_messageInfo_AuthReply proto.InternalMessageInfo

func (m *AuthReply) GetAuthJWT() string {
	if m != nil {
		return m.AuthJWT
	}
	return ""
}

type RegisterRequest struct {
	KID        string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Expiry     int64  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry,omitempty"`
	SigAlg     string `protobuf:"bytes,3,opt,name=sigAlg,proto3" json:"sig_alg,omitempty"`
	SigBits    int32  `protobuf:"varint,4,opt,name=sigBits,proto3" json:"sig_bits,omitempty"`
	EncAlg     string `protobuf:"bytes,5,opt,name=encAlg,proto3" json:"enc_alg,omitempty"`
	EncBits    int32  `protobuf:"varint,6,opt,name=encBits,proto3" json:"enc_bits,omitempty"`
	AuthTTL    int64  `protobuf:"varint,7,opt,name=authTTL,proto3" json:"auth_ttl,omitempty"`
	RefreshTTL int64  `protobuf:"varint,8,opt,name=refreshTTL,proto3" json:"refresh_ttl,omitempty"`
	// RefreshStrategy is used in RenewJWT to decide wheather to issue new refresh
	// token with access token or not this option applies to all renewJWT requests
	RefreshStrategy string `protobuf:"bytes,9,opt,name=refreshStrategy,proto3" json:"refresh_strategy,omitempty"`
}

func (m *RegisterRequest) Reset()         { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()    {}
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{8}
}
func (m *RegisterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterRequest.Merge(m, src)
}
func (m *RegisterRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterRequest proto.InternalMessageInfo

func (m *RegisterRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RegisterRequest) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *RegisterRequest) GetSigAlg() string {
	if m != nil {
		return m.SigAlg
	}
	return ""
}

func (m *RegisterRequest) GetSigBits() int32 {
	if m != nil {
		return m.SigBits
	}
	return 0
}

func (m *RegisterRequest) GetEncAlg() string {
	if m != nil {
		return m.EncAlg
	}
	return ""
}

func (m *RegisterRequest) GetEncBits() int32 {
	if m != nil {
		return m.EncBits
	}
	return 0
}

func (m *RegisterRequest) GetAuthTTL() int64 {
	if m != nil {
		return m.AuthTTL
	}
	return 0
}

func (m *RegisterRequest) GetRefreshTTL() int64 {
	if m != nil {
		return m.RefreshTTL
	}
	return 0
}

func (m *RegisterRequest) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type RegisterReply struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	AuthJWT         string `protobuf:"bytes,2,opt,name=authJWT,proto3" json:"auth_jwt"`
	PubSigKey       []byte `protobuf:"bytes,3,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey       []byte `protobuf:"bytes,4,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Expiry          int64  `protobuf:"varint,5,opt,name=expiry,proto3" json:"expiry"`
	Valid           bool   `protobuf:"varint,6,opt,name=valid,proto3" json:"valid"`
	RefreshStrategy string `protobuf:"bytes,7,opt,name=refreshStrategy,proto3" json:"refresh_strategy"`
}

func (m *RegisterReply) Reset()         { *m = RegisterReply{} }
func (m *RegisterReply) String() string { return proto.CompactTextString(m) }
func (*RegisterReply) ProtoMessage()    {}
func (*RegisterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{9}
}
func (m *RegisterReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterReply.Merge(m, src)
}
func (m *RegisterReply) XXX_Size() int {
	return m.Size()
}
func (m *RegisterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterReply proto.InternalMessageInfo

func (m *RegisterReply) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *RegisterReply) GetAuthJWT() string {
	if m != nil {
		return m.AuthJWT
	}
	return ""
}

func (m *RegisterReply) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *RegisterReply) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *RegisterReply) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *RegisterReply) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *RegisterReply) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

type UpdateKeysRequest struct {
}

func (m *UpdateKeysRequest) Reset()         { *m = UpdateKeysRequest{} }
func (m *UpdateKeysRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateKeysRequest) ProtoMessage()    {}
func (*UpdateKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{10}
}
func (m *UpdateKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeysRequest.Merge(m, src)
}
func (m *UpdateKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeysRequest proto.InternalMessageInfo

type UpdateKeysReply struct {
}

func (m *UpdateKeysReply) Reset()         { *m = UpdateKeysReply{} }
func (m *UpdateKeysReply) String() string { return proto.CompactTextString(m) }
func (*UpdateKeysReply) ProtoMessage()    {}
func (*UpdateKeysReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{11}
}
func (m *UpdateKeysReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateKeysReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateKeysReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateKeysReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateKeysReply.Merge(m, src)
}
func (m *UpdateKeysReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdateKeysReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateKeysReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateKeysReply proto.InternalMessageInfo

type ListKeysRequest struct {
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query"`
}

func (m *ListKeysRequest) Reset()         { *m = ListKeysRequest{} }
func (m *ListKeysRequest) String() string { return proto.CompactTextString(m) }
func (*ListKeysRequest) ProtoMessage()    {}
func (*ListKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{12}
}
func (m *ListKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysRequest.Merge(m, src)
}
func (m *ListKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysRequest proto.InternalMessageInfo

func (m *ListKeysRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// KeysInfo holds all keys info
type KeysInfo struct {
	KID             string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	Expiry          int64  `protobuf:"varint,2,opt,name=expiry,proto3" json:"expiry"`
	AuthTTL         int64  `protobuf:"varint,3,opt,name=authTTL,proto3" json:"auth_ttl"`
	RefreshTTL      int64  `protobuf:"varint,4,opt,name=refreshTTL,proto3" json:"refresh_ttl"`
	RefreshStrategy string `protobuf:"bytes,5,opt,name=refreshStrategy,proto3" json:"refresh_strategy"`
	PubSigKey       []byte `protobuf:"bytes,6,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey       []byte `protobuf:"bytes,7,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Locked          bool   `protobuf:"varint,8,opt,name=locked,proto3" json:"locked"`
	Valid           bool   `protobuf:"varint,9,opt,name=valid,proto3" json:"valid"`
	Expired         bool   `protobuf:"varint,10,opt,name=expired,proto3" json:"expired"`
}

func (m *KeysInfo) Reset()         { *m = KeysInfo{} }
func (m *KeysInfo) String() string { return proto.CompactTextString(m) }
func (*KeysInfo) ProtoMessage()    {}
func (*KeysInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{13}
}
func (m *KeysInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeysInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeysInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeysInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeysInfo.Merge(m, src)
}
func (m *KeysInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeysInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeysInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeysInfo proto.InternalMessageInfo

func (m *KeysInfo) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *KeysInfo) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *KeysInfo) GetAuthTTL() int64 {
	if m != nil {
		return m.AuthTTL
	}
	return 0
}

func (m *KeysInfo) GetRefreshTTL() int64 {
	if m != nil {
		return m.RefreshTTL
	}
	return 0
}

func (m *KeysInfo) GetRefreshStrategy() string {
	if m != nil {
		return m.RefreshStrategy
	}
	return ""
}

func (m *KeysInfo) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *KeysInfo) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *KeysInfo) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

func (m *KeysInfo) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *KeysInfo) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

type ListKeysReply struct {
	Keys []*KeysInfo `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys"`
}

func (m *ListKeysReply) Reset()         { *m = ListKeysReply{} }
func (m *ListKeysReply) String() string { return proto.CompactTextString(m) }
func (*ListKeysReply) ProtoMessage()    {}
func (*ListKeysReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{14}
}
func (m *ListKeysReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKeysReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKeysReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKeysReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKeysReply.Merge(m, src)
}
func (m *ListKeysReply) XXX_Size() int {
	return m.Size()
}
func (m *ListKeysReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKeysReply.DiscardUnknown(m)
}

var xxx_messageInfo_ListKeysReply proto.InternalMessageInfo

func (m *ListKeysReply) GetKeys() []*KeysInfo {
	if m != nil {
		return m.Keys
	}
	return nil
}

type DelKeysRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *DelKeysRequest) Reset()         { *m = DelKeysRequest{} }
func (m *DelKeysRequest) String() string { return proto.CompactTextString(m) }
func (*DelKeysRequest) ProtoMessage()    {}
func (*DelKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{15}
}
func (m *DelKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelKeysRequest.Merge(m, src)
}
func (m *DelKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *DelKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DelKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DelKeysRequest proto.InternalMessageInfo

func (m *DelKeysRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type DelKeysReply struct {
}

func (m *DelKeysReply) Reset()         { *m = DelKeysReply{} }
func (m *DelKeysReply) String() string { return proto.CompactTextString(m) }
func (*DelKeysReply) ProtoMessage()    {}
func (*DelKeysReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{16}
}
func (m *DelKeysReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelKeysReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelKeysReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelKeysReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelKeysReply.Merge(m, src)
}
func (m *DelKeysReply) XXX_Size() int {
	return m.Size()
}
func (m *DelKeysReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DelKeysReply.DiscardUnknown(m)
}

var xxx_messageInfo_DelKeysReply proto.InternalMessageInfo

type PublicKeysRequest struct {
	KID string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
}

func (m *PublicKeysRequest) Reset()         { *m = PublicKeysRequest{} }
func (m *PublicKeysRequest) String() string { return proto.CompactTextString(m) }
func (*PublicKeysRequest) ProtoMessage()    {}
func (*PublicKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{17}
}
func (m *PublicKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeysRequest.Merge(m, src)
}
func (m *PublicKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeysRequest proto.InternalMessageInfo

func (m *PublicKeysRequest) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

type PublicKeysReply struct {
	KID       string `protobuf:"bytes,1,opt,name=kid,proto3" json:"kid"`
	PubSigKey []byte `protobuf:"bytes,2,opt,name=pubSigKey,proto3" json:"pub_sig_key"`
	PubEncKey []byte `protobuf:"bytes,3,opt,name=pubEncKey,proto3" json:"pub_enc_key"`
	Expiry    int64  `protobuf:"varint,4,opt,name=expiry,proto3" json:"expiry"`
	Valid     bool   `protobuf:"varint,5,opt,name=valid,proto3" json:"valid"`
}

func (m *PublicKeysReply) Reset()         { *m = PublicKeysReply{} }
func (m *PublicKeysReply) String() string { return proto.CompactTextString(m) }
func (*PublicKeysReply) ProtoMessage()    {}
func (*PublicKeysReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_4491f5b5b43ef287, []int{18}
}
func (m *PublicKeysReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeysReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeysReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeysReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeysReply.Merge(m, src)
}
func (m *PublicKeysReply) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeysReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeysReply.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeysReply proto.InternalMessageInfo

func (m *PublicKeysReply) GetKID() string {
	if m != nil {
		return m.KID
	}
	return ""
}

func (m *PublicKeysReply) GetPubSigKey() []byte {
	if m != nil {
		return m.PubSigKey
	}
	return nil
}

func (m *PublicKeysReply) GetPubEncKey() []byte {
	if m != nil {
		return m.PubEncKey
	}
	return nil
}

func (m *PublicKeysReply) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *PublicKeysReply) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func init() {
	proto.RegisterType((*NewJWTRequest)(nil), "pb.NewJWTRequest")
	proto.RegisterType((*NewJWTReply)(nil), "pb.NewJWTReply")
	proto.RegisterType((*RenewJWTRequest)(nil), "pb.RenewJWTRequest")
	proto.RegisterType((*RenewJWTReply)(nil), "pb.RenewJWTReply")
	proto.RegisterType((*RevokeJWTRequest)(nil), "pb.RevokeJWTRequest")
	proto.RegisterType((*RevokeJWTReply)(nil), "pb.RevokeJWTReply")
	proto.RegisterType((*AuthRequest)(nil), "pb.AuthRequest")
	proto.RegisterType((*AuthReply)(nil), "pb.AuthReply")
	proto.RegisterType((*RegisterRequest)(nil), "pb.RegisterRequest")
	proto.RegisterType((*RegisterReply)(nil), "pb.RegisterReply")
	proto.RegisterType((*UpdateKeysRequest)(nil), "pb.UpdateKeysRequest")
	proto.RegisterType((*UpdateKeysReply)(nil), "pb.UpdateKeysReply")
	proto.RegisterType((*ListKeysRequest)(nil), "pb.ListKeysRequest")
	proto.RegisterType((*KeysInfo)(nil), "pb.KeysInfo")
	proto.RegisterType((*ListKeysReply)(nil), "pb.ListKeysReply")
	proto.RegisterType((*DelKeysRequest)(nil), "pb.DelKeysRequest")
	proto.RegisterType((*DelKeysReply)(nil), "pb.DelKeysReply")
	proto.RegisterType((*PublicKeysRequest)(nil), "pb.PublicKeysRequest")
	proto.RegisterType((*PublicKeysReply)(nil), "pb.PublicKeysReply")
}

func init() { proto.RegisterFile("jwtis.proto", fileDescriptor_4491f5b5b43ef287) }

var fileDescriptor_4491f5b5b43ef287 = []byte{
	// 1049 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x6a, 0xe3, 0x46,
	0x14, 0x5e, 0x49, 0xfe, 0x3d, 0xb6, 0x63, 0x7b, 0xb2, 0x29, 0xae, 0x29, 0x96, 0x11, 0x74, 0x09,
	0x65, 0x13, 0x17, 0x2f, 0x81, 0x96, 0x42, 0x61, 0xc5, 0x16, 0x9a, 0x1f, 0x4a, 0x51, 0x5c, 0x72,
	0x69, 0x6c, 0x79, 0xa2, 0x68, 0xad, 0x58, 0x5a, 0x6b, 0x9c, 0xd4, 0x8f, 0xd0, 0xbb, 0xbe, 0x4b,
	0x7b, 0x55, 0xfa, 0x00, 0xbd, 0xdc, 0xab, 0x52, 0x4a, 0x11, 0xc5, 0xb9, 0xd3, 0x53, 0x94, 0xf9,
	0x91, 0xf5, 0x93, 0xa4, 0xb1, 0xf7, 0xc6, 0xb2, 0xbe, 0xf9, 0x8e, 0xce, 0x99, 0x73, 0xbe, 0x73,
	0x66, 0xa0, 0xf2, 0xf6, 0x96, 0xd8, 0xfe, 0xa1, 0x37, 0x77, 0x89, 0x8b, 0x64, 0x6f, 0xdc, 0x3e,
	0xb0, 0x6c, 0x72, 0xb5, 0x18, 0x1f, 0x9a, 0xee, 0x75, 0xcf, 0x72, 0x2d, 0xb7, 0xc7, 0x96, 0xc6,
	0x8b, 0x4b, 0xf6, 0xc6, 0x5e, 0xd8, 0x3f, 0x6e, 0xa2, 0x0d, 0xa1, 0xf6, 0x1d, 0xbe, 0x3d, 0xb9,
	0x18, 0x18, 0xf8, 0xdd, 0x02, 0xfb, 0x04, 0x75, 0x41, 0x99, 0xda, 0x93, 0x96, 0xd4, 0x95, 0xf6,
	0xcb, 0xfa, 0xce, 0x2a, 0x50, 0x95, 0xd3, 0xe3, 0x37, 0x61, 0xa0, 0x52, 0xd4, 0xa0, 0x3f, 0xe8,
	0x25, 0x14, 0x4c, 0x67, 0x64, 0x5f, 0xfb, 0x2d, 0xb9, 0x2b, 0xed, 0x57, 0xf5, 0xe7, 0x61, 0xa0,
	0x36, 0x38, 0xf2, 0xd2, 0xbd, 0xb6, 0x09, 0xbe, 0xf6, 0xc8, 0xd2, 0x10, 0x1c, 0xed, 0x37, 0x09,
	0x2a, 0x91, 0x07, 0xcf, 0x59, 0xa2, 0x4f, 0x40, 0x5e, 0x7f, 0xbe, 0xba, 0x0a, 0x54, 0x99, 0x7d,
	0x5d, 0xb6, 0x27, 0x86, 0x6c, 0x4f, 0x50, 0x1f, 0x2a, 0x23, 0xd3, 0xc4, 0xbe, 0x3f, 0x70, 0xa7,
	0x78, 0xc6, 0x1c, 0x94, 0xf5, 0x46, 0x18, 0xa8, 0x55, 0x0e, 0x0f, 0x09, 0xc5, 0x8d, 0x24, 0x09,
	0x1d, 0x41, 0x75, 0x8e, 0x2f, 0xe7, 0xd8, 0xbf, 0xe2, 0x46, 0x0a, 0x33, 0x6a, 0x86, 0x81, 0x5a,
	0x13, 0xb8, 0xb0, 0x4a, 0xd1, 0x90, 0x06, 0x05, 0xfc, 0xa3, 0x67, 0xcf, 0x97, 0xad, 0x5c, 0x57,
	0xda, 0x57, 0x74, 0x08, 0x03, 0x55, 0x20, 0x86, 0x78, 0x6a, 0xbf, 0x4a, 0x50, 0x37, 0xf0, 0x6c,
	0xcb, 0x04, 0x65, 0x03, 0x92, 0x37, 0x0b, 0xe8, 0x5b, 0xa8, 0x8b, 0xf7, 0x73, 0x32, 0x1f, 0x11,
	0x6c, 0x2d, 0xc5, 0x56, 0x3a, 0x61, 0xa0, 0xb6, 0x23, 0x4b, 0x5f, 0xac, 0x25, 0x52, 0x9d, 0x35,
	0xd3, 0xea, 0x50, 0x8b, 0xa3, 0xf6, 0x9c, 0xa5, 0xf6, 0x93, 0x04, 0x0d, 0x03, 0xdf, 0xb8, 0x53,
	0xbc, 0xd5, 0x46, 0x78, 0xad, 0xe4, 0x47, 0x6a, 0xf5, 0x61, 0x79, 0xd7, 0x1a, 0xb0, 0x93, 0x08,
	0x85, 0x46, 0xd7, 0x83, 0xca, 0xeb, 0x05, 0xb9, 0xda, 0x38, 0x2e, 0xed, 0x15, 0x94, 0xb9, 0x01,
	0x15, 0xd4, 0x0b, 0x28, 0x8e, 0x16, 0xe4, 0xea, 0xe4, 0x62, 0x10, 0xa9, 0x2a, 0x0c, 0xd4, 0x12,
	0x85, 0x86, 0x6f, 0x6f, 0x89, 0x11, 0x2d, 0x6a, 0x7f, 0x2b, 0xb4, 0x96, 0x96, 0xed, 0x13, 0x3c,
	0xdf, 0x4a, 0xec, 0x42, 0x25, 0x32, 0x53, 0x09, 0x13, 0x3b, 0x47, 0x92, 0x62, 0xe7, 0x08, 0x3a,
	0x80, 0x82, 0x6f, 0x5b, 0xaf, 0x1d, 0x4b, 0x24, 0x63, 0x2f, 0x0c, 0xd4, 0xa6, 0x6f, 0x5b, 0xc3,
	0x91, 0x63, 0x25, 0xe9, 0x9c, 0x84, 0x3e, 0x87, 0xa2, 0x6f, 0x5b, 0xba, 0x4d, 0x7c, 0xa6, 0xc1,
	0xbc, 0xfe, 0x51, 0x18, 0xa8, 0x88, 0xf2, 0xc7, 0x36, 0x49, 0x36, 0x53, 0x44, 0xa3, 0x0e, 0xf0,
	0xcc, 0xa4, 0x0e, 0xf2, 0xb1, 0x03, 0x3c, 0x33, 0xb3, 0x0e, 0x38, 0x89, 0x3a, 0xc0, 0x33, 0x93,
	0x39, 0x28, 0xc4, 0x0e, 0x28, 0x3f, 0xeb, 0x40, 0xd0, 0xa8, 0x05, 0x4d, 0xd8, 0x60, 0x70, 0xd6,
	0x2a, 0xb2, 0x0d, 0x33, 0x0b, 0x96, 0x4d, 0x42, 0x9c, 0xa4, 0x85, 0xa0, 0xa1, 0x2f, 0x01, 0xa2,
	0xfa, 0x0e, 0xce, 0x5a, 0x25, 0x66, 0xf4, 0x71, 0x18, 0xa8, 0x7b, 0x6b, 0x11, 0xa4, 0xec, 0x12,
	0xe4, 0x87, 0x14, 0x5f, 0xfe, 0x30, 0xc5, 0xff, 0x2e, 0x53, 0xc9, 0x47, 0xc5, 0xa5, 0xb2, 0x78,
	0xba, 0xb4, 0x09, 0xe1, 0xc8, 0xff, 0x23, 0x1c, 0x74, 0x00, 0x65, 0x6f, 0x31, 0x3e, 0xb7, 0xad,
	0x53, 0xcc, 0x3b, 0xb2, 0xaa, 0xd7, 0xc3, 0x40, 0xad, 0x78, 0x8b, 0xf1, 0x90, 0xd6, 0x6a, 0x8a,
	0x97, 0x46, 0xcc, 0x10, 0xf4, 0x6f, 0x66, 0x26, 0xa5, 0xe7, 0xd2, 0x74, 0x9a, 0xf9, 0x88, 0xce,
	0x19, 0x89, 0x31, 0x94, 0x7f, 0x6c, 0x0c, 0x21, 0x15, 0xf2, 0x37, 0x23, 0xc7, 0x9e, 0xb0, 0x22,
	0x96, 0xf4, 0x72, 0x18, 0xa8, 0x1c, 0x30, 0xf8, 0x03, 0x7d, 0x7d, 0x3f, 0x91, 0x45, 0xb6, 0x25,
	0x26, 0xd7, 0x6c, 0x22, 0xef, 0xa7, 0x6f, 0x17, 0x9a, 0x3f, 0x78, 0x93, 0x11, 0xc1, 0xa7, 0x78,
	0xe9, 0x8b, 0xe6, 0xd0, 0x9a, 0x50, 0x4f, 0x82, 0xb4, 0x53, 0xfb, 0x50, 0x3f, 0xb3, 0x7d, 0x92,
	0x60, 0xd1, 0xd8, 0xde, 0x2d, 0xf0, 0x7c, 0x29, 0x32, 0xcd, 0x62, 0x63, 0x80, 0xc1, 0x1f, 0xda,
	0x2f, 0x0a, 0x94, 0xa8, 0xc1, 0xf1, 0xec, 0xd2, 0xdd, 0xa0, 0x2a, 0x5a, 0xa6, 0xe1, 0x1e, 0xca,
	0xc7, 0x8b, 0x58, 0xa4, 0x0a, 0x23, 0xc5, 0x95, 0x23, 0xc4, 0x89, 0xa5, 0xd9, 0x4b, 0x49, 0x93,
	0x8f, 0x79, 0x56, 0x8b, 0x84, 0x34, 0x53, 0x82, 0x7c, 0x20, 0x8f, 0xf9, 0x2d, 0xf2, 0x98, 0x96,
	0x4a, 0x61, 0x3b, 0xa9, 0x14, 0x37, 0x91, 0x8a, 0xe3, 0x9a, 0x53, 0x3c, 0x61, 0x5d, 0x56, 0xe2,
	0xa9, 0xe1, 0x88, 0x21, 0x9e, 0xb1, 0x54, 0xca, 0x8f, 0x48, 0xe5, 0x53, 0x28, 0xb2, 0x2c, 0xe2,
	0x49, 0x0b, 0x18, 0xa5, 0x12, 0x06, 0x6a, 0x04, 0x19, 0xd1, 0x1f, 0xed, 0x2b, 0xa8, 0xc5, 0x95,
	0xa6, 0xfd, 0xf4, 0x19, 0xe4, 0xa6, 0x78, 0xe9, 0xb7, 0xa4, 0xae, 0xb2, 0x5f, 0xe9, 0x57, 0x0f,
	0xbd, 0xf1, 0x61, 0x54, 0x55, 0xbd, 0x14, 0x06, 0x2a, 0x5b, 0x35, 0xd8, 0xaf, 0xd6, 0x87, 0x9d,
	0x37, 0xd8, 0x49, 0xaa, 0xe4, 0xe9, 0x99, 0xbe, 0x03, 0xd5, 0xb5, 0x0d, 0x95, 0xda, 0x11, 0x34,
	0xbf, 0x5f, 0x8c, 0x1d, 0xdb, 0xdc, 0xee, 0x33, 0x7f, 0x4a, 0x50, 0x4f, 0xda, 0x6d, 0x36, 0x0a,
	0x52, 0x75, 0x93, 0xb7, 0xab, 0x9b, 0xb2, 0x45, 0x8b, 0xe7, 0x9e, 0x6e, 0xf1, 0xfc, 0xc3, 0x75,
	0xeb, 0xff, 0xa3, 0x40, 0xf5, 0xe4, 0x62, 0x70, 0x7c, 0x7e, 0x8e, 0xe7, 0x37, 0xb6, 0x89, 0xe9,
	0xc9, 0xc4, 0xef, 0x55, 0xa8, 0x49, 0x8b, 0x91, 0xba, 0xc5, 0xb5, 0xeb, 0x49, 0x88, 0xe6, 0xa0,
	0x0f, 0xa5, 0xe8, 0x4a, 0x80, 0x76, 0xe9, 0x62, 0xe6, 0x5a, 0xd3, 0x6e, 0xa6, 0x41, 0x6a, 0x73,
	0x04, 0xe5, 0xf5, 0x49, 0x8d, 0x9e, 0xf3, 0xf5, 0xf4, 0x1d, 0xa2, 0x8d, 0x32, 0x28, 0x3f, 0x90,
	0x73, 0xf4, 0x74, 0x46, 0x2c, 0x86, 0xc4, 0xc1, 0xde, 0xae, 0xc5, 0xc0, 0x3a, 0x24, 0x3e, 0xb2,
	0xa3, 0x90, 0x52, 0xa7, 0x73, 0x14, 0x52, 0x72, 0xaa, 0x7f, 0x01, 0x10, 0xcf, 0x24, 0xb4, 0x47,
	0x09, 0xf7, 0x06, 0x57, 0x7b, 0x37, 0x0b, 0x0b, 0x6f, 0x91, 0xa0, 0xb9, 0xb7, 0xcc, 0x20, 0xe3,
	0xde, 0xd2, 0x9a, 0xef, 0x41, 0x51, 0x68, 0x12, 0xb1, 0x8d, 0xa6, 0x45, 0xdd, 0x6e, 0xa4, 0x30,
	0x11, 0x5e, 0x2c, 0x3e, 0x1e, 0xde, 0x3d, 0x11, 0xf3, 0xf0, 0x32, 0x1a, 0xd5, 0x5b, 0x7f, 0xac,
	0x3a, 0xd2, 0xfb, 0x55, 0x47, 0xfa, 0x77, 0xd5, 0x91, 0x7e, 0xbe, 0xeb, 0x3c, 0x7b, 0x7f, 0xd7,
	0x79, 0xf6, 0xd7, 0x5d, 0xe7, 0xd9, 0xb8, 0xc0, 0x2e, 0xea, 0xaf, 0xfe, 0x0b, 0x00, 0x00, 0xff,
	0xff, 0x31, 0xb2, 0x9d, 0x08, 0xea, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// JWTISServiceClient is the client API for JWTISService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JWTISServiceClient interface {
	NewJWT(ctx context.Context, in *NewJWTRequest, opts ...grpc.CallOption) (*NewJWTReply, error)
	RenewJWT(ctx context.Context, in *RenewJWTRequest, opts ...grpc.CallOption) (*RenewJWTReply, error)
	RevokeJWT(ctx context.Context, in *RevokeJWTRequest, opts ...grpc.CallOption) (*RevokeJWTReply, error)
	Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthReply, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error)
	UpdateKeys(ctx context.Context, in *UpdateKeysRequest, opts ...grpc.CallOption) (*UpdateKeysReply, error)
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysReply, error)
	DelKeys(ctx context.Context, in *DelKeysRequest, opts ...grpc.CallOption) (*DelKeysReply, error)
	PublicKeys(ctx context.Context, in *PublicKeysRequest, opts ...grpc.CallOption) (*PublicKeysReply, error)
}

type jWTISServiceClient struct {
	cc *grpc.ClientConn
}

func NewJWTISServiceClient(cc *grpc.ClientConn) JWTISServiceClient {
	return &jWTISServiceClient{cc}
}

func (c *jWTISServiceClient) NewJWT(ctx context.Context, in *NewJWTRequest, opts ...grpc.CallOption) (*NewJWTReply, error) {
	out := new(NewJWTReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/NewJWT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) RenewJWT(ctx context.Context, in *RenewJWTRequest, opts ...grpc.CallOption) (*RenewJWTReply, error) {
	out := new(RenewJWTReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/RenewJWT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) RevokeJWT(ctx context.Context, in *RevokeJWTRequest, opts ...grpc.CallOption) (*RevokeJWTReply, error) {
	out := new(RevokeJWTReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/RevokeJWT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthReply, error) {
	out := new(AuthReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error) {
	out := new(RegisterReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) UpdateKeys(ctx context.Context, in *UpdateKeysRequest, opts ...grpc.CallOption) (*UpdateKeysReply, error) {
	out := new(UpdateKeysReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/UpdateKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysReply, error) {
	out := new(ListKeysReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/ListKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) DelKeys(ctx context.Context, in *DelKeysRequest, opts ...grpc.CallOption) (*DelKeysReply, error) {
	out := new(DelKeysReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/DelKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jWTISServiceClient) PublicKeys(ctx context.Context, in *PublicKeysRequest, opts ...grpc.CallOption) (*PublicKeysReply, error) {
	out := new(PublicKeysReply)
	err := c.cc.Invoke(ctx, "/pb.JWTISService/PublicKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JWTISServiceServer is the server API for JWTISService service.
type JWTISServiceServer interface {
	NewJWT(context.Context, *NewJWTRequest) (*NewJWTReply, error)
	RenewJWT(context.Context, *RenewJWTRequest) (*RenewJWTReply, error)
	RevokeJWT(context.Context, *RevokeJWTRequest) (*RevokeJWTReply, error)
	Auth(context.Context, *AuthRequest) (*AuthReply, error)
	Register(context.Context, *RegisterRequest) (*RegisterReply, error)
	UpdateKeys(context.Context, *UpdateKeysRequest) (*UpdateKeysReply, error)
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysReply, error)
	DelKeys(context.Context, *DelKeysRequest) (*DelKeysReply, error)
	PublicKeys(context.Context, *PublicKeysRequest) (*PublicKeysReply, error)
}

// UnimplementedJWTISServiceServer can be embedded to have forward compatible implementations.
type UnimplementedJWTISServiceServer struct {
}

func (*UnimplementedJWTISServiceServer) NewJWT(ctx context.Context, req *NewJWTRequest) (*NewJWTReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewJWT not implemented")
}
func (*UnimplementedJWTISServiceServer) RenewJWT(ctx context.Context, req *RenewJWTRequest) (*RenewJWTReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewJWT not implemented")
}
func (*UnimplementedJWTISServiceServer) RevokeJWT(ctx context.Context, req *RevokeJWTRequest) (*RevokeJWTReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeJWT not implemented")
}
func (*UnimplementedJWTISServiceServer) Auth(ctx context.Context, req *AuthRequest) (*AuthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (*UnimplementedJWTISServiceServer) Register(ctx context.Context, req *RegisterRequest) (*RegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (*UnimplementedJWTISServiceServer) UpdateKeys(ctx context.Context, req *UpdateKeysRequest) (*UpdateKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeys not implemented")
}
func (*UnimplementedJWTISServiceServer) ListKeys(ctx context.Context, req *ListKeysRequest) (*ListKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}
func (*UnimplementedJWTISServiceServer) DelKeys(ctx context.Context, req *DelKeysRequest) (*DelKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKeys not implemented")
}
func (*UnimplementedJWTISServiceServer) PublicKeys(ctx context.Context, req *PublicKeysRequest) (*PublicKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicKeys not implemented")
}

func RegisterJWTISServiceServer(s *grpc.Server, srv JWTISServiceServer) {
	s.RegisterService(&_JWTISService_serviceDesc, srv)
}

func _JWTISService_NewJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).NewJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/NewJWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).NewJWT(ctx, req.(*NewJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_RenewJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).RenewJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/RenewJWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).RenewJWT(ctx, req.(*RenewJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_RevokeJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).RevokeJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/RevokeJWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).RevokeJWT(ctx, req.(*RevokeJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).Auth(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_UpdateKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).UpdateKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/UpdateKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).UpdateKeys(ctx, req.(*UpdateKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/ListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_DelKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).DelKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/DelKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).DelKeys(ctx, req.(*DelKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JWTISService_PublicKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JWTISServiceServer).PublicKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.JWTISService/PublicKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JWTISServiceServer).PublicKeys(ctx, req.(*PublicKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _JWTISService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.JWTISService",
	HandlerType: (*JWTISServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewJWT",
			Handler:    _JWTISService_NewJWT_Handler,
		},
		{
			MethodName: "RenewJWT",
			Handler:    _JWTISService_RenewJWT_Handler,
		},
		{
			MethodName: "RevokeJWT",
			Handler:    _JWTISService_RevokeJWT_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _JWTISService_Auth_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _JWTISService_Register_Handler,
		},
		{
			MethodName: "UpdateKeys",
			Handler:    _JWTISService_UpdateKeys_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _JWTISService_ListKeys_Handler,
		},
		{
			MethodName: "DelKeys",
			Handler:    _JWTISService_DelKeys_Handler,
		},
		{
			MethodName: "PublicKeys",
			Handler:    _JWTISService_PublicKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "jwtis.proto",
}

func (m *NewJWTRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewJWTRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewJWTRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Claims) > 0 {
		i -= len(m.Claims)
		copy(dAtA[i:], m.Claims)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.Claims)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewJWTReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewJWTReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewJWTReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiry != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenewJWTRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewJWTRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewJWTRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenewJWTReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewJWTReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewJWTReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RevokeJWTRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokeJWTRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokeJWTRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RevokeJWTReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokeJWTReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokeJWTReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthJWT) > 0 {
		i -= len(m.AuthJWT)
		copy(dAtA[i:], m.AuthJWT)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.AuthJWT)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RefreshTTL != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.RefreshTTL))
		i--
		dAtA[i] = 0x40
	}
	if m.AuthTTL != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.AuthTTL))
		i--
		dAtA[i] = 0x38
	}
	if m.EncBits != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.EncBits))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EncAlg) > 0 {
		i -= len(m.EncAlg)
		copy(dAtA[i:], m.EncAlg)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.EncAlg)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SigBits != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.SigBits))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SigAlg) > 0 {
		i -= len(m.SigAlg)
		copy(dAtA[i:], m.SigAlg)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.SigAlg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expiry != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Expiry != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthJWT) > 0 {
		i -= len(m.AuthJWT)
		copy(dAtA[i:], m.AuthJWT)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.AuthJWT)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateKeysReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateKeysReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateKeysReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeysInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeysInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeysInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired {
		i--
		if m.Expired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RefreshStrategy) > 0 {
		i -= len(m.RefreshStrategy)
		copy(dAtA[i:], m.RefreshStrategy)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.RefreshStrategy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RefreshTTL != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.RefreshTTL))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthTTL != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.AuthTTL))
		i--
		dAtA[i] = 0x18
	}
	if m.Expiry != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKeysReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKeysReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKeysReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Keys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintJwtis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelKeysReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelKeysReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelKeysReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PublicKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKeysReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeysReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeysReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Expiry != 0 {
		i = encodeVarintJwtis(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PubEncKey) > 0 {
		i -= len(m.PubEncKey)
		copy(dAtA[i:], m.PubEncKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubEncKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubSigKey) > 0 {
		i -= len(m.PubSigKey)
		copy(dAtA[i:], m.PubSigKey)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.PubSigKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KID) > 0 {
		i -= len(m.KID)
		copy(dAtA[i:], m.KID)
		i = encodeVarintJwtis(dAtA, i, uint64(len(m.KID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintJwtis(dAtA []byte, offset int, v uint64) int {
	offset -= sovJwtis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NewJWTRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.Claims)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *NewJWTReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovJwtis(uint64(m.Expiry))
	}
	return n
}

func (m *RenewJWTRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *RenewJWTReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RevokeJWTRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *RevokeJWTReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *AuthReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthJWT)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *RegisterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovJwtis(uint64(m.Expiry))
	}
	l = len(m.SigAlg)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.SigBits != 0 {
		n += 1 + sovJwtis(uint64(m.SigBits))
	}
	l = len(m.EncAlg)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.EncBits != 0 {
		n += 1 + sovJwtis(uint64(m.EncBits))
	}
	if m.AuthTTL != 0 {
		n += 1 + sovJwtis(uint64(m.AuthTTL))
	}
	if m.RefreshTTL != 0 {
		n += 1 + sovJwtis(uint64(m.RefreshTTL))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *RegisterReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.AuthJWT)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovJwtis(uint64(m.Expiry))
	}
	if m.Valid {
		n += 2
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *UpdateKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateKeysReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *KeysInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovJwtis(uint64(m.Expiry))
	}
	if m.AuthTTL != 0 {
		n += 1 + sovJwtis(uint64(m.AuthTTL))
	}
	if m.RefreshTTL != 0 {
		n += 1 + sovJwtis(uint64(m.RefreshTTL))
	}
	l = len(m.RefreshStrategy)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Locked {
		n += 2
	}
	if m.Valid {
		n += 2
	}
	if m.Expired {
		n += 2
	}
	return n
}

func (m *ListKeysReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovJwtis(uint64(l))
		}
	}
	return n
}

func (m *DelKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *DelKeysReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PublicKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	return n
}

func (m *PublicKeysReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KID)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubSigKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	l = len(m.PubEncKey)
	if l > 0 {
		n += 1 + l + sovJwtis(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovJwtis(uint64(m.Expiry))
	}
	if m.Valid {
		n += 2
	}
	return n
}

func sovJwtis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozJwtis(x uint64) (n int) {
	return sovJwtis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NewJWTRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewJWTRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewJWTRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claims", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claims = append(m.Claims[:0], dAtA[iNdEx:postIndex]...)
			if m.Claims == nil {
				m.Claims = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewJWTReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewJWTReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewJWTReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewJWTRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewJWTRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewJWTRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewJWTReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewJWTReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewJWTReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeJWTRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeJWTRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeJWTRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeJWTReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeJWTReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeJWTReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthJWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthJWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigBits", wireType)
			}
			m.SigBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncAlg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncAlg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncBits", wireType)
			}
			m.EncBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncBits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTTL", wireType)
			}
			m.AuthTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTTL", wireType)
			}
			m.RefreshTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthJWT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthJWT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateKeysReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateKeysReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateKeysReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeysInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeysInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeysInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthTTL", wireType)
			}
			m.AuthTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTTL", wireType)
			}
			m.RefreshTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshStrategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKeysReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKeysReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKeysReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KeysInfo{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelKeysReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelKeysReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelKeysReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeysReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeysReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeysReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubSigKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubSigKey = append(m.PubSigKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubSigKey == nil {
				m.PubSigKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubEncKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthJwtis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthJwtis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubEncKey = append(m.PubEncKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubEncKey == nil {
				m.PubEncKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJwtis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJwtis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJwtis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJwtis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJwtis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthJwtis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupJwtis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthJwtis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthJwtis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJwtis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupJwtis = fmt.Errorf("proto: unexpected end of group")
)
